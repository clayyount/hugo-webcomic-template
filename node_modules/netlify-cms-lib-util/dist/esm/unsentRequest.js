"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _immutable = require("immutable");

var _curry = _interopRequireDefault(require("lodash/curry"));

var _flow = _interopRequireDefault(require("lodash/flow"));

var _isString = _interopRequireDefault(require("lodash/isString"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const decodeParams = paramsString => (0, _immutable.List)(paramsString.split('&')).map(s => (0, _immutable.List)(s.split('=')).map(decodeURIComponent)).update(_immutable.Map);

const fromURL = wholeURL => {
  const [url, allParamsString] = wholeURL.split('?');
  return (0, _immutable.Map)(_objectSpread({
    url
  }, allParamsString ? {
    params: decodeParams(allParamsString)
  } : {}));
};

const encodeParams = params => params.entrySeq().map((_ref) => {
  let [k, v] = _ref;
  return "".concat(encodeURIComponent(k), "=").concat(encodeURIComponent(v));
}).join('&');

const toURL = req => "".concat(req.get('url')).concat(req.get('params') ? "?".concat(encodeParams(req.get('params'))) : '');

const toFetchArguments = req => [toURL(req), req.delete('url').delete('params').toJS()];

const maybeRequestArg = req => {
  if ((0, _isString.default)(req)) {
    return fromURL(req);
  }

  if (req) {
    return (0, _immutable.fromJS)(req);
  }

  return (0, _immutable.Map)();
};

const ensureRequestArg = func => req => func(maybeRequestArg(req));

const ensureRequestArg2 = func => (arg, req) => func(arg, maybeRequestArg(req)); // This actually performs the built request object


const performRequest = ensureRequestArg(req => fetch(...toFetchArguments(req))); // Each of the following functions takes options and returns another
// function that performs the requested action on a request. They each
// default to containing an empty object, so you can simply call them
// without arguments to generate a request with only those properties.

const getCurriedRequestProcessor = (0, _flow.default)([ensureRequestArg2, _curry.default]);

const getPropSetFunctions = path => [getCurriedRequestProcessor((val, req) => req.setIn(path, val)), getCurriedRequestProcessor((val, req) => req.getIn(path) ? req : req.setIn(path, val))];

const getPropMergeFunctions = path => [getCurriedRequestProcessor((obj, req) => req.updateIn(path, function () {
  let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.Map)();
  return p.merge(obj);
})), getCurriedRequestProcessor((obj, req) => req.updateIn(path, function () {
  let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.Map)();
  return (0, _immutable.Map)(obj).merge(p);
}))];

const [withMethod, withDefaultMethod] = getPropSetFunctions(['method']);
const [withBody, withDefaultBody] = getPropSetFunctions(['body']);
const [withParams, withDefaultParams] = getPropMergeFunctions(['params']);
const [withHeaders, withDefaultHeaders] = getPropMergeFunctions(['headers']); // withRoot sets a root URL, unless the URL is already absolute

const absolutePath = new RegExp('^(?:[a-z]+:)?//', 'i');
const withRoot = getCurriedRequestProcessor((root, req) => req.update('url', p => {
  if (absolutePath.test(p)) {
    return p;
  }

  return root && p && p[0] !== '/' && root[root.length - 1] !== '/' ? "".concat(root, "/").concat(p) : "".concat(root).concat(p);
})); // withTimestamp needs no argument and has to run as late as possible,
// so it calls `withParams` only when it's actually called with a
// request.

const withTimestamp = ensureRequestArg(req => withParams({
  ts: new Date().getTime()
}, req));
var _default = {
  toURL,
  fromURL,
  performRequest,
  withMethod,
  withDefaultMethod,
  withBody,
  withDefaultBody,
  withHeaders,
  withDefaultHeaders,
  withParams,
  withDefaultParams,
  withRoot,
  withTimestamp
};
exports.default = _default;